+++
categories = ["golang"]
date = "2015-11-11T12:30:49+09:00"
title = "go zg"

+++

勉強もかねて、Go言語で[rupa/z](https://github.com/rupa/z)の再実装をしている。  
z.shとは、zshやbashなどのターミナル下で最近訪れたディレクトリを、独自のアルゴリズムを使って  
リスト化するシェルスクリプト。

perl界で名高く、最近はGoでも活躍されている[lestrrat](https://github.com/lestrrat)さんが  
開発している[peco](https://github.com/peco/peco)が日本でちょっとしたブームとなったのをきっかけに、  
相性の良い[rupa/z](https://github.com/rupa/z)も話題になっていたよう。

といっても[rupa/z](https://github.com/rupa/z)自体は昔からあったようで[rupa/j](https://github.com/rupa/j)から[rupa/j2](https://github.com/rupa/j2)を経て、今のものがあるみたい。  
GitHubのrepository descriptionにある、

> z is the new j, yo

がなんとなくかっこ良い…

pecoの良さはどんなツールにも適応できるとこだけど、その魅力についてはまた次回。

## rupa/z
まずは`frecency`と名付けられているアルゴリズムについて。

まずは、ユーザーがディレクトリにアクセスした際に、そのディレクトリパスを、zshであれば_precmd()など  
を使ってシェルから取得して、`.z`というファイルに書き込む。

同時にそのディレクトリの最終アクセス履歴をUnix時間で取得して、同じ行のパスの後に書き込もうとする。  
Unix時間に関しては以下のような感じ。

```
Unix    :  1447212043
Readable:  2015-11-11 12:20:43 +0900 JST
```

厳密には調べてないけど、ある日にちを元に今日までの経過時間を計算する、Linuxなどで共通的に  
使われるフォーマット。  

それを元に、以下のような感じでif文を使って比較して、rankと変数名をつけられているものを導き出す。

```bash
function frecent(rank, time) {
    dx = t-time
    if( dx < 3600 ) return rank*4
    if( dx < 86400 ) return rank*2
    if( dx < 604800 ) return rank/2
    return rank/4
}
```

引数として受けたrank変数値(Unix時間: int64)を、条件にしたがって上下させてる。  

- 1時間以内にアクセスがあったディレクトリであれば、rankを4倍
-   1日以内にアクセスがあったディレクトリであれば、rankを2倍
- 1週間以内にアクセスがあったディレクトリであれば、rankを2等
- 1時間以内にアクセスがあったディレクトリであれば、rankを4等

といった感じで、最終的なrank値をreturnする。  
簡単ではあるけど、理にかなったアルゴリズムみたい。

あとは繰り返しが行われて、現在のカレントパスから移動するたびにどんどん`.z`に書き込みを行っていく。  

そうして出来上がったパスとrankの羅列されたファイルを元に、指示された内容でソートしてアウトプット  
するのが一連のながれ。  
cliインターフェイスはもちろん持っていて、適当なフラグを指定すればそれに準じたソートでパスをstdout  
に表示する。  
フラグ無しの場合は、その独自のアルゴリズムで評価したrank値を元にソート、表示。


内容を読んでみたら単純で理解しやすいものなのだけど、だからこそGoでの再実装にはもってこいな材料だな  
と思ったのでやってみる。  
とりあえずはメインの機能を実装して、吐き出すログを同じものにし、shellのアウトプットの速度に  
勝つことを目標に。  
といっても並行処理など使われているわけではないので、さすがに大幅に間違った実装しなければ  
Goが用意しているconcurrency、goroutineを使えば速度面は向上できそうだなと思ってる。

ところで、Goの日付処理に関して参考になったのが、複数人いるともっぱらの話題なmattn氏のブログポスト  

http://mattn.kaoriya.net/software/lang/go/20130620173712.htm

timeパッケージの主要な部分の事が書かれていてすぐに理解できた。  
最初は実装に戸惑ったらしい。  
ぼくは標準ライブラリを使ってちゃんとやろうとしてるのはGoが初めてなので、あぁそういうもんか、としか  
印象を持たなかった…  

差異を言語側で隠蔽して、書く側はあまり考えなくても良いのがGoの書きやすさの特徴でもあるはずなので、  
がっつり恩恵に預かって、実装を進めていこうかと思います。
